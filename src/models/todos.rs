use chrono::NaiveDateTime;
use diesel::{
    prelude::*, AsChangeset, Identifiable, Insertable, PgConnection, Queryable, RunQueryDsl,
};
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::schema::todos::{self, dsl::*};

/// Todo struct representing a row in the todos table in the database
#[derive(Identifiable, Queryable, Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct Todo {
    /// Unique id of the todo
    /// This is the primary key of the todos table
    /// This is auto generated by the database
    pub id: i32,
    /// Id of the user who created the todo
    pub user_id: i32,
    /// Title of the todo
    pub title: String,
    /// Description of the todo
    pub description: String,
    /// Whether the todo is completed or not
    pub completed: bool,
    // /// Time the todo was created
    // /// This is auto generated by the database
    // /// This is the time the todo was created in UTC
    // pub created_at: NaiveDateTime,
    // /// Time the todo was updated
    // /// This is auto generated by the database
    // /// This is the time the todo was updated in UTC
    // pub updated_at: NaiveDateTime,
}

/// TodoDTO struct representing the data to be sent to the database to create or update a new todo
#[derive(Insertable, AsChangeset, Serialize, Deserialize, Debug, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
#[table_name = "todos"]
pub struct TodoDTO {
    /// Id of the user who created the todo
    /// The user_id is gotten from the token
    pub user_id: Option<i32>,
    /// Title of the todo
    /// Title is required for creating a new todo
    /// Title is optional for updating a todo
    /// If title is not provided, the title of the todo will not be updated
    /// If title is provided, the title of the todo will be updated
    pub title: Option<String>,
    /// Description of the todo
    /// Description is optional for updating a new todo
    /// If description is not provided, the description of the todo will not be updated
    pub description: Option<String>,
    /// Whether the todo is completed or not
    pub completed: Option<bool>,
}

/// Implementation of the Todo struct
impl Todo {
    /// Create a new todo function
    /// # Arguments
    /// * `data` - TodoDTO struct containing the data to be sent to the database
    /// * `conn` - Mutable reference to the database connection
    /// # Returns
    /// * `Result<String, String>` - Result containing a success message or an error message
    ///
    pub fn new_todo(data: TodoDTO, conn: &mut PgConnection) -> Result<String, String> {
        let validation = Todo::validate_input_new_todo(data.clone());

        if validation.is_err() {
            return Err(validation.err().unwrap());
        }

        let result = diesel::insert_into(todos).values(&data).execute(conn);

        match result {
            Ok(_) => Ok("Successfully created todo".to_string()),
            Err(_) => Err("Failed to create todo".to_string()),
        }
    }

    /// Update a todo function
    /// # Arguments
    /// * `todo_id` - Id of the todo to be updated
    /// * `data` - TodoDTO struct containing the data to be sent to the database
    /// * `conn` - Mutable reference to the database connection
    /// # Returns
    /// * `Result<String, String>` - Result containing a success message or an error message
    pub fn update_todo(
        todo_id: i32,
        data: TodoDTO,
        conn: &mut PgConnection,
    ) -> Result<String, String> {
        let result = diesel::update(todos)
            .set(&data)
            .filter(id.eq(todo_id))
            .execute(conn);

        match result {
            Ok(_) => Ok("Successfully updated todo".to_string()),
            Err(_) => Err("Failed to update todo".to_string()),
        }
    }

    /// Gets all todos from the user function
    /// # Arguments
    /// * `user` - Id of the user to get todos from
    /// * `conn` - Mutable reference to the database connection
    /// # Returns
    /// * `Result<Vec<Todo>, String>` - Result containing a vector of todos or an error message
    pub fn get_todos(user: i32, conn: &mut PgConnection) -> Result<Vec<Todo>, String> {
        let result = todos.filter(user_id.eq(user)).load(conn);

        match result {
            Ok(data) => Ok(data),
            Err(_) => Err("Failed to get todos".to_string()),
        }
    }

    /// Internal function to validate input for creating a new todo
    /// # Arguments
    /// * `data` - TodoDTO struct containing the data to be sent to the database
    /// # Returns
    /// * `Result<(), String>` - Result containing a success message or an error message
    fn validate_input_new_todo(data: TodoDTO) -> Result<(), String> {
        if Some(data.title) == None {
            return Err("Title is required".to_string());
        }

        if Some(data.description) == None {
            return Err("Description is required".to_string());
        }

        return Ok(());
    }
}
