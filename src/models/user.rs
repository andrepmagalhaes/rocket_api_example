use bcrypt::{hash, verify, DEFAULT_COST};
use chrono::NaiveDateTime;
use diesel::{prelude::*, Identifiable, Insertable, PgConnection, Queryable};
use rocket_okapi::okapi::schemars;
use rocket_okapi::okapi::schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::config::db::Connection;
use crate::schema::users::{self, dsl::*};

/// User struct representing a row in the users table in the database
/// This is the model for the users table
/// This is the struct that will be used to interact with the users table
#[derive(Identifiable, Queryable, Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct User {
    /// Unique id of the user
    /// This is the primary key of the users table
    /// This is auto generated by the database
    pub id: i32,
    /// Name of the user
    pub name: String,
    /// Email of the user
    pub email: String,
    /// Password of the user
    pub password: String,
    // /// Time the user was created
    // /// This is auto generated by the database
    // /// This is the time the user was created in UTC
    // pub created_at: NaiveDateTime,
    // /// Time the user was updated
    // /// This is auto generated by the database
    // /// This is the time the user was updated in UTC
    // pub updated_at: NaiveDateTime,
}

/// UserDTO struct representing the data to be sent to the database to create a new user
/// This is the struct that will be used to create a new user
/// This is the struct that will be used to signup a new user
#[derive(Insertable, Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase")]
#[table_name = "users"]
pub struct UserDTO {
    /// Name of the user
    /// Name is required for creating a new user
    pub name: String,
    /// Password of the user
    /// Password is required for creating a new user
    pub password: String,
    /// Email of the user
    /// Email is required for creating a new user
    pub email: String,
}

/// UserLoginDTO struct representing the data to be sent for signing in a user
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
pub struct UserLoginDTO {
    /// Email of the user
    /// Email is required for signing in a user
    /// Email is used to find the user in the database
    /// Email is used to verify the password of the user
    pub email: String,
    /// Password of the user
    /// Password is required for signing in a user
    /// Password is used to verify the user
    pub password: String,
}

/// Implementation of the User struct
/// This is where we implement the functions of the User struct
impl User {
    /// Find a user by email function
    /// # Arguments
    /// * `user` - UserDTO struct containing the data needed to create a new user
    /// * `conn` - Connection to the database
    /// # Returns
    /// * `Result<User, String>` - Result containing a message if it was successful or not
    pub fn signup(user: UserDTO, conn: &mut Connection) -> Result<String, String> {
        let already_exists = User::find_by_email(user.email.clone(), conn);

        if already_exists.is_ok() {
            return Err("User already exists".to_string());
        }

        let hashed_password = hash(user.password, DEFAULT_COST);
        let hashed_password_result = match hashed_password {
            Ok(hashed_password) => hashed_password,
            Err(_) => return Err("Failed to hash password".to_string()),
        };

        let new_user = UserDTO {
            name: user.name,
            password: hashed_password_result,
            email: user.email,
        };

        let result = diesel::insert_into(users).values(&new_user).execute(conn);

        if result.is_err() {
            return Err("Failed to create user".to_string());
        }

        return Ok("User created".to_string());
    }

    /// Login a user function
    /// # Arguments
    /// * `user_login` - UserLoginDTO struct containing the data needed to login a user
    /// * `conn` - Connection to the database
    /// # Returns
    /// * `Result<User, String>` - Result containing the user data if successful or a message if not
    pub fn login(user_login: UserLoginDTO, conn: &mut Connection) -> Result<User, String> {
        let user = User::find_by_email(user_login.email, conn);

        let user_result = match user {
            Ok(user) => user,
            Err(_) => {
                return Err("User not found".to_string());
            }
        };
        println!("{:?}", user_login.password);
        println!("{:?}", user_result);

        let password_matches = verify(user_login.password, &user_result.password);

        print!("{:?}", password_matches);

        if password_matches.is_err() {
            return Err("Failed to verify password".to_string());
        }

        if !password_matches.unwrap() {
            return Err("Password does not match".to_string());
        }

        return Ok(user_result);
    }

    /// Internal function to find a user by email
    /// # Arguments
    /// * `requested_email` - String containing the email of the user to find
    /// * `conn` - Connection to the database
    /// # Returns
    /// * `Result<User, String>` - Result containing the user data if successful or a message if not
    fn find_by_email(requested_email: String, conn: &mut PgConnection) -> Result<User, String> {
        let result = users.filter(email.eq(requested_email)).first(conn);

        println!("find_by_email res => {:?}", result);

        match result {
            Ok(user) => return Ok(user),
            Err(_) => return Err("User not found".to_string()),
        }
    }
}
